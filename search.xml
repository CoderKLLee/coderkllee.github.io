<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【iOS 搭建基础框架】编码规范 (代码格式篇)]]></title>
    <url>%2F2018%2F01%2F24%2F%E3%80%90iOS-%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E3%80%91%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83-%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本篇是 【iOS 搭建基础框架】系列，编码规范 的第二篇 代码格式篇。 其他相关文章传送门如下： 【iOS 搭建基础框架】编码规范 (命名规范篇)/ ) 本篇内容，摘取自苹果、谷歌的文档翻译，还有网上大神们贡献的资料。 希望能让你有所收获，没有收获也没关系，记得点赞~ 🙂 代码格式缩进不要在工程里使用Tab键，使用空格来进行缩进。不要去修改Xcode &gt; Preferences &gt; Text Editing里的Tab和自动缩进的默认的 4 个空格设置，即使用 Xcode 的默认设置即可。 方法的书写一个典型的 Objective-C 方法应该是这样的： 123- (void)writeVideoFrameWithData:(NSData *)frameData timeStamp:(int)timeStamp &#123;...&#125; 在-和(void)之间应该有一个空格，第一个大括号{的位置在方法所在行的末尾，同样应该有一个空格。 如果一个方法有特别多的参数或者名称很长，应该将其按照:来对齐分行显示： 1234567891011-(id)initWithModel:(IPCModle)modelConnectType:(IPCConnectType)connectTypeResolution:(IPCResolution)resolutionAuthName:(NSString *)authNamePassword:(NSString *)passwordMAC:(NSString *)macAzIp:(NSString *)az_ipAzDns:(NSString *)az_dnsToken:(NSString *)tokenEmail:(NSString *)emailDelegate:(id&lt;IPCConnectHandlerDelegate&gt;)delegate; 在分行时，如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进： 123456- (void)short:(GTMFoo *)theFoolongKeyword:(NSRect)theRectevenLongerKeyword:(float)theIntervalerror:(NSError **)theError &#123;...&#125; 方法调用方法调用的格式和书写差不多，可以按照方法的长短来选择写在一行或者分成多行： 12345678910111213//写在一行[myObject doFooWith:arg1 name:arg2 error:arg3];//分行写，按照':'对齐[myObject doFooWith:arg1name:arg2error:arg3];//第一段名称过短的话后续可以进行缩进[myObj short:arg1longKeyword:arg2evenLongerKeyword:arg3error:arg4]; 以下写法是错误的： 12345678910//错误，要么写在一行，要么全部分行[myObject doFooWith:arg1 name:arg2error:arg3];[myObject doFooWith:arg1name:arg2 error:arg3];//错误，按照':'来对齐，而不是关键字[myObject doFooWith:arg1name:arg2error:arg3]; @public和@private标记符@public和@private标记符应该以 一个空格 来进行缩进： 1234567@interface MyClass : NSObject &#123;@public...@private...&#125;@end 协议（Protocols）在书写协议的时候注意用&lt;&gt;括起来的协议和类型名之间是没有空格的，比如IPCConnectHandler()&lt;IPCPreconnectorDelegate&gt;,这个规则适用所有书写协议的地方，包括方法声明、类声明、实例变量等等： 1234567@interface MyProtocoledClass : NSObject&lt;NSWindowDelegate&gt; &#123;@privateid&lt;MyFancyDelegate&gt; _delegate;&#125;- (void)setDelegate:(id&lt;MyFancyDelegate&gt;)aDelegate;@end 闭包（Blocks）根据block的长度，有不同的书写规则： 较短的block可以写在一行内。 如果分行显示的话，block的右括号}应该和调用block那行代码的第一个非空字符对齐。 block内的代码采用4个空格的缩进。 如果block过于庞大，应该单独声明成一个变量来使用。 ^和(之间，^和{之间都没有空格，参数列表的右括号)和{之间有一个空格。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//较短的block写在一行内[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];//分行书写的block，内部使用4空格缩进[operation setCompletionBlock:^&#123;[self.delegate newDataAvailable];&#125;];//使用C语言API调用的block遵循同样的书写规则dispatch_async(_fileIOQueue, ^&#123;NSString* path = [self sessionFilePath];if (path) &#123;// ...&#125;&#125;);//较长的block关键字可以缩进后在新行书写，注意block的右括号'&#125;'和调用block那行代码的第一个非空字符对齐[[SessionService sharedService]loadWindowWithCompletionBlock:^(SessionWindow *window) &#123;if (window) &#123;[self windowDidLoad:window];&#125; else &#123;[self errorLoadingWindow];&#125;&#125;];//较长的block参数列表同样可以缩进后在新行书写[[SessionService sharedService]loadWindowWithCompletionBlock:^(SessionWindow *window) &#123;if (window) &#123;[self windowDidLoad:window];&#125; else &#123;[self errorLoadingWindow];&#125;&#125;];//庞大的block应该单独定义成变量使用void (^largeBlock)(void) = ^&#123;// ...&#125;;[_operationQueue addOperationWithBlock:largeBlock];//在一个调用中使用多个block，注意到他们不是像方法那样通过':'对齐的，而是同时进行了4个空格的缩进[myObject doSomethingWith:arg1firstBlock:^(Foo *a) &#123;// ...&#125;secondBlock:^(Bar *b) &#123;// ...&#125;]; 数据结构的字面量写法应该使用可读性更好的字面量来构造NSArray，NSDictionary等数据结构，避免使用冗长的alloc,init方法。 如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来： 1234567//正确，在字面量的"[]"或者"&#123;&#125;"两端留有空格NSArray *array = @[ [foo description], @"Another String", [bar description] ];NSDictionary *dict = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;//不正确，不留有空格降低了可读性NSArray* array = @[[foo description], [bar description]];NSDictionary* dict = @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;; 如果构造代码不写在一行内，构造元素需要使用 两个空格 来进行缩进，右括号]或者}写在新的一行，并且与调用字面量那行代码的第一个非空字符对齐： 1234567891011NSArray *array = @[@"This",@"is",@"an",@"array"];NSDictionary *dictionary = @&#123;NSFontAttributeName : [NSFont fontWithName:@"Helvetica-Bold" size:12],NSForegroundColorAttributeName : fontColor&#125;; 构造字典时，字典的Key和Value与中间的冒号:都要留有一个空格，多行书写时，也可以将Value对齐： 123456789101112131415161718192021222324252627//正确，冒号':'前后留有一个空格NSDictionary *option1 = @&#123;NSFontAttributeName : [NSFont fontWithName:@"Helvetica-Bold" size:12],NSForegroundColorAttributeName : fontColor&#125;;//正确，按照Value来对齐NSDictionary *option2 = @&#123;NSFontAttributeName : [NSFont fontWithName:@"Arial" size:12],NSForegroundColorAttributeName : fontColor&#125;;//错误，冒号前应该有一个空格NSDictionary *wrong = @&#123;AKey: @"b",BLongerKey: @"c",&#125;;//错误，每一个元素要么单独成为一行，要么全部写在一行内NSDictionary *alsoWrong= @&#123; AKey : @"a",BLongerKey : @"b" &#125;;//错误，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐NSDictionary *stillWrong = @&#123;AKey : @"b",BLongerKey : @"c",&#125;; nil检查因为在 Objective-C 中向nil对象发送命令是不会抛出异常或者导致崩溃的，只是完全的“什么都不干”，所以，只在程序中使用nil来做逻辑上的检查。 另外，不要使用诸如nil == Object或者Object == nil的形式来判断。 123456789//正确，直接判断if (!objc) &#123;... &#125;//错误，不要使用nil == Object的形式if (nil == objc) &#123;... &#125; 哥们，都浪到这了，顺手点个赞❤️呗~ 参考文档 Apple Coding Guidelines for Cocoa Objective-C-Coding-Guidelines-In-Chinese]]></content>
  </entry>
  <entry>
    <title><![CDATA[【iOS 搭建基础框架】编码规范 (命名规范篇)]]></title>
    <url>%2F2018%2F01%2F22%2F%E3%80%90iOS-%E6%90%AD%E5%BB%BA%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6%E3%80%91%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本篇是 【iOS 搭建基础框架】系列，编码规范 的第一篇 命名规范篇。 其他相关文章传送门如下： 【iOS 搭建基础框架】编码规范 (代码格式篇)/ ) 本篇内容，摘取自苹果、谷歌的文档翻译，还有网上大神们贡献的资料。 主要是为了让自己保持代码的一致性 and 传说中的优雅 🙂 ，也为以后的团队总结出一份基础的通用编码规范。(确实想的有点远 🙂) 希望能让你有所收获，没有收获也没关系，记得点赞~ 🙂 命名规范类名 (Class) 避免潜在的命名冲突，设置 Class Prefix 设置整个项目的统一类名前缀。由于苹果公司保留使用”两个字母前缀”的所有权，所以项目里的前缀应取三个字母为宜。 类名的命名采用 大驼峰命名法 即每个单词的首字母大写。 类别 (Category)如下：类别名添加 大写前缀 KL ， 方法名添加 小写前缀 kl 。 1234567NSObject+KLNetworkingMethods.h@interface NSObject (KLNetworkingMethods)- (BOOL)kl_isEmptyObject;@end 委托 (Delegate) 第一个参数是触发委托的对象 第一个关键词是触发对象的类名 除非该方法只有一个参数 12345// 第一个关键词为触发委托的类名- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section; // 当只有一个"sender"参数时可以省略类名- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender; 根据委托方法触发的时机和目的，使用should,will,did等关键词 12345- (void)browserDidScroll:(NSBrowser *)sender;- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;、- (BOOL)windowShouldClose:(id)sender; 通知 (Notification)通知常用于在模块间传递消息，所以通知要尽可能地表示出发生的事件，通知的命名范式是： 1[触发通知的类名] + [Did | Will] + [动作] + Notification 栗子🌰 1234NSApplicationDidBecomeActiveNotificationUIKeyboardWillShowNotificationNSUserDefaultsDidChangeNotificationUITextFieldTextDidBeginEditingNotification 方法(Methods)命名采用 小驼峰命名法 即首个单词全部用小写字母，后续的单词首字母大写。 方法名中不应该有标点符号(包括下划线)，除了以下的情况： 可以用带下划线的小写前缀来命名私有方法或者类别中的方法 1- (void)kl_setControls 如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用do，does这种多余的关键字，动词本身的暗示就足够了： 123456//正确，使用属性名来命名方法- (NSSize)cellSize;//错误，添加了多余的动词前缀- (NSSize)calcCellSize;- (NSSize)getCellSize; 对于有多个参数的方法，务必在每一个参数前都添加关键词，关键词应当清晰说明参数的作用： 1234567891011//正确，保证每个参数都有关键词修饰- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;//错误，遗漏关键词- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;//正确- (id)viewWithTag:(NSInteger)aTag;//错误，关键词的作用不清晰- (id)taggedView:(int)aTag; 不要用and来连接两个参数，通常and用来表示方法执行了两个相对独立的操作（从设计上来说，这时候应该拆分成两个独立的方法）： 12345//错误，不要使用"and"来连接参数- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;//正确，使用"and"来表示两个相对独立的操作- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag; 方法的参数命名也有一些需要注意的地方: 和方法名类似，参数的第一个字母小写，后面的每一个单词首字母大写 不要再方法名中使用类似pointer,ptr这样的字眼去表示指针，参数本身的类型足以说明 不要使用只有一两个字母的参数名 不要使用简写，拼出完整的单词 存取方法（Accessor Methods）存取方法是指用来获取和设置类属性值的方法，属性的不同类型，对应着不同的存取方法规范： 1234567891011121314151617181920//属性是一个名词时的存取方法范式- (type)noun;- (void)setNoun:(type)aNoun;//栗子- (NSString *)title;- (void)setTitle:(NSString *)aTitle;//属性是一个形容词时存取方法的范式- (BOOL)isAdjective;- (void)setAdjective:(BOOL)flag;//栗子- (BOOL)isEditable;- (void)setEditable:(BOOL)flag;//属性是一个动词时存取方法的范式- (BOOL)verbObject;- (void)setVerbObject:(BOOL)flag;//栗子- (BOOL)showsAlpha;- (void)setShowsAlpha:(BOOL)flag; 命名存取方法时不要将动词转化为被动形式来使用： 1234567//正确- (void)setAcceptsGlyphInfo:(BOOL)flag;- (BOOL)acceptsGlyphInfo;//错误，不要使用动词的被动形式- (void)setGlyphInfoAccepted:(BOOL)flag;- (BOOL)glyphInfoAccepted; 可以使用can,should,will等词来协助表达存取方法的意思，但不要使用do,和does： 123456789//正确- (void)setCanHide:(BOOL)flag;- (BOOL)canHide;- (void)setShouldCloseDocument:(BOOL)flag;- (BOOL)shouldCloseDocument;//错误，不要使用"do"或者"does"- (void)setDoesAcceptGlyphInfo:(BOOL)flag;- (BOOL)doesAcceptGlyphInfo; 为什么 Objective-C 中不适用get前缀来表示属性获取方法？因为get在 Objective-C 中通常只用来表示从函数指针返回值的函数： 12//三个参数都是作为函数的返回值来使用的，这样的函数名可以使用"get"前缀- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase; 集合操作类方法（Collection Methods）有些对象管理着一系列其它对象或者元素的集合，需要使用类似“增删查改”的方法来对集合进行操作，这些方法的命名范式一般为： 123456789//集合操作范式- (void)addElement:(elementType)anObj;- (void)removeElement:(elementType)anObj;- (NSArray *)elements;//栗子- (void)addLayoutManager:(NSLayoutManager *)obj;- (void)removeLayoutManager:(NSLayoutManager *)obj;- (NSArray *)layoutManagers; 注意，如果返回的集合是无序的，使用NSSet来代替NSArray。如果需要将元素插入到特定的位置，使用类似于这样的命名： 12- (void)insertLayoutManager:(NSLayoutManager *)obj atIndex:(int)index;- (void)removeLayoutManagerAtIndex:(int)index; 如果管理的集合元素中有指向管理对象的指针，要设置成weak类型以防止引用循环。 下面是SDK中NSWindow类的集合操作方法： 12345- (void)addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;- (void)removeChildWindow:(NSWindow *)childWin;- (NSArray *)childWindows;- (NSWindow *)parentWindow;- (void)setParentWindow:(NSWindow *)window; 命名属性和实例变量（Properties&amp;Instance Variables）属性和对象的存取方法相关联，属性的第一个字母小写，后续单词首字母大写，不必添加前缀。属性按功能命名成名词或者动词： 12345//名词属性@property (strong) NSString *title;//动词属性@property (assign) BOOL showsAlpha; 属性也可以命名成形容词，这时候通常会指定一个带有is前缀的get方法来提高可读性： 1@property (assign, getter=isEditable) BOOL editable; 命名实例变量，在变量名前加上_前缀（有些有历史的代码会将_放在后面），其它和命名属性一样： 123@implementation MyClass &#123;BOOL _showsTitle;&#125; 一般来说，类需要对使用者隐藏数据存储的细节，所以不要将实例方法定义成公共可访问的接口，可以使用@private，@protected前缀。 按苹果的说法，不建议在除了init和dealloc方法以外的地方直接访问实例变量，但很多人认为直接访问会让代码更加清晰可读，只在需要计算或者执行操作的时候才使用存取方法访问，我就是这种习惯，所以这里不作要求。 ###命名常量（Constants） 如果要定义一组相关的常量，尽量使用枚举类型（enumerations），枚举类型的命名规则和函数的命名规则相同。建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，参见官方的 Adopting Modern Objective-C 一文： 1234567//定义一个枚举typedef NS_ENUM(NSInteger, NSMatrixMode) &#123;NSRadioModeMatrix,NSHighlightModeMatrix,NSListModeMatrix,NSTrackModeMatrix&#125;; 定义bit map： 1234567typedef NS_OPTIONS(NSUInteger, NSWindowMask) &#123;NSBorderlessWindowMask = 0,NSTitledWindowMask = 1 &lt;&lt; 0,NSClosableWindowMask = 1 &lt;&lt; 1,NSMiniaturizableWindowMask = 1 &lt;&lt; 2,NSResizableWindowMask = 1 &lt;&lt; 3&#125;; 使用const定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举。常量的命名规范和函数相同： 1const float NSLightGray; 不要使用#define宏来定义常量，如果是整型常量，尽量使用枚举，浮点型常量，使用const定义。#define通常用来给编译器决定是否编译某块代码，比如常用的： 1#ifdef DEBUG 注意到一般由编译器定义的宏会在前后都有一个__，比如__MACH__。 注释文件注释每一个文件都 必须 写文件注释，文件注释最基本的应包含 文件名称 作者信息(姓名、邮箱、Github等) 文件的描述，及其作用 版本信息 最基础的文件注释栗子🌰 1234567891011/*******************************************************************************File name: AppDelegate.hAuthor: Ferryman (Li KaiLong)Description:History:********************************************************************************/ 在 Xcode 里，创建的新文件都有默认的文件注释，可通过 Xcode 9 的 自定义文本宏 新特性统一添加我们的文件注释模块，保持整个工程统一的文件注释风格。 重要！很重要！！ 非常重要！！！ 代码注释“自解释”（self-documenting）的代码是我们应该做到的，但仍然需要详细的注释来说明参数的意义、返回值、功能以及可能的副作用。 方法、类、协议、类别的定义都需要注释，推荐采用Apple的标准注释风格，好处是可以在引用的地方option + 鼠标左键自动弹出注释，非常方便。 生成注释格式的方法采用 Xcode 自带的注释快捷键功能 单行注释：在需要注释的地方按 command + / 标注： 在属性或者方法名的上面(空白) 的地方按 command + option + / 特别注意： 协议、委托的注释要明确说明其被触发的条件 如果在注释中要引用参数名或者方法函数名，使用||将参数或者方法括起来以避免歧义： 定义在头文件里的接口方法、属性必须要有注释！ 哥们，都浪到这了，顺手点个赞❤️呗~ 参考文档 Apple Coding Guidelines for Cocoa Objective-C-Coding-Guidelines-In-Chinese]]></content>
  </entry>
</search>
